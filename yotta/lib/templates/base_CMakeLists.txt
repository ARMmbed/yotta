# NOTE: This file is generated by yotta: changes will be overwritten!

{% if toplevel %}
cmake_minimum_required(VERSION 2.8.11)

enable_testing()

# add a dummy target for all autogenerated tests, so we can build them all
# even though they are EXCLUDE_FROMALL'd, if you use custom CMakeLists you can
# add a dependency of this target on your test programs, by adding:
# add_dependencies(all_tests your_test_name)
add_custom_target(all_tests)


# always use the CMAKE_MODULE_PATH-provided .cmake files, even when including
# from system directories:
cmake_policy(SET CMP0017 OLD)

# toolchain file for {{ target_name }}
set(CMAKE_TOOLCHAIN_FILE "{{ toolchain_file | replaceBackslashes }}")

# provide function for post-processing executables
function (yotta_postprocess_target target_type_ target_name_)
    if(COMMAND yotta_apply_target_rules)
        yotta_apply_target_rules(${target_type_} ${target_name_})
    endif()

    # For backwards compatibility, support YOTTA_POSTPROCESS_COMMAND.
    if(DEFINED YOTTA_POSTPROCESS_COMMAND AND ${target_type_} STREQUAL "EXECUTABLE")
        #message(AUTHOR_WARNING "This target defines a YOTTA_POSTPROCESS_COMMAND for which support has been deprecated. Please define a CMake function yotta_apply_target_rules(build_object_type build_object) instead.")
        string(REPLACE YOTTA_CURRENT_EXE_NAME "${target_name_}" LOCAL_POSTPROCESS_COMMAND "${YOTTA_POSTPROCESS_COMMAND}")
        separate_arguments(LOCAL_POSTPROCESS_COMMAND_SEPARATED UNIX_COMMAND ${LOCAL_POSTPROCESS_COMMAND})
        add_custom_command(
            TARGET ${target_name_}
            POST_BUILD
            COMMAND ${LOCAL_POSTPROCESS_COMMAND_SEPARATED}
        )
    endif()
endfunction()

# set target-defined definitions
{{ set_definitions }}
{% endif %}

project({{ component_name }})

{% if toplevel %}
# Definitions provided by the target configuration info:
if(NOT DEFINED YOTTA_FORCE_INCLUDE_FLAG)
    set(YOTTA_FORCE_INCLUDE_FLAG "-include")
endif()
add_definitions("${YOTTA_FORCE_INCLUDE_FLAG} \"{{ config_include_file | replaceBackslashes }}\"")
{% endif %}

# include root directories of all components we depend on (directly and
# indirectly, including ourself)
{{ include_root_dirs }}

# recurse into dependencies that aren't built elsewhere
{{ add_depend_subdirs }}

{% if include_sys_dirs %}
# Some components (I'm looking at you, libc), need to export system header
# files with no prefix, these directories are listed in the component
# description files:
{{ include_sys_dirs }}
{% endif %}

{% if include_other_dirs %}
# And others (typically CMSIS implementations) need to export non-system header
# files. Please don't use this facility. Please. It's much, much better to fix
# implementations that import these headers to import them using the full path.
{{ include_other_dirs }}
{% endif %}

# modules with custom CMake build systems may append to the
# YOTTA_GLOBAL_INCLUDE_DIRS property to add compile-time-determined include
# directories:
get_property(GLOBAL_INCLUDE_DIRS GLOBAL PROPERTY YOTTA_GLOBAL_INCLUDE_DIRS)
include_directories(${GLOBAL_INCLUDE_DIRS})

# Provide the version of the component being built, in case components want to
# embed this into compiled libraries
set(YOTTA_COMPONENT_VERSION "{{ component_version }}")
add_definitions(-DYOTTA_COMPONENT_VERSION="{{ component_version }}")

{% if delegate_to %}
# delegate to an existing CMakeLists.txt:
add_subdirectory(
    "{{ delegate_to | replaceBackslashes }}"
    "{{ delegate_build_dir | replaceBackslashes }}"
)
{% else %}
# recurse into subdirectories for this component, using the two-argument
# add_subdirectory because the directories referred to here exist in the source
# tree, not the working directory
{% for srcdir, workingdir in add_own_subdirs %}
add_subdirectory(
    "{{ srcdir | replaceBackslashes }}"
    "{{ workingdir | replaceBackslashes }}"
)
{% endfor %}
{% endif %}
