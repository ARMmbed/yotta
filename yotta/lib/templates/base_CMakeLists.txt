# NOTE: This file is generated by yotta: changes will be overwritten!

{% if toplevel %}
cmake_minimum_required(VERSION 2.8.11)

enable_testing()

# add a dummy target for all autogenerated tests, so we can build them all
# even though they are EXCLUDE_FROMALL'd, if you use custom CMakeLists you can
# add a dependency of this target on your test programs, by adding:
# add_dependencies(all_tests your_test_name)
add_custom_target(all_tests)


# always use the CMAKE_MODULE_PATH-provided .cmake files, even when including
# from system directories:
cmake_policy(SET CMP0017 OLD)

# toolchain file for {{ target_name }}
set(CMAKE_TOOLCHAIN_FILE "{{ toolchain_file | replaceBackslashes }}")

# provide function for post-processing executables
function (yotta_postprocess_target target_type_ target_name_)
    if(COMMAND yotta_apply_target_rules)
        yotta_apply_target_rules(${target_type_} ${target_name_})
    endif()

    # For backwards compatibility, support YOTTA_POSTPROCESS_COMMAND.
    if(DEFINED YOTTA_POSTPROCESS_COMMAND AND ${target_type_} STREQUAL "EXECUTABLE")
        #message(AUTHOR_WARNING "This target defines a YOTTA_POSTPROCESS_COMMAND for which support has been deprecated. Please define a CMake function yotta_apply_target_rules(build_object_type build_object) instead.")
        string(REPLACE YOTTA_CURRENT_EXE_NAME "${target_name_}" LOCAL_POSTPROCESS_COMMAND "${YOTTA_POSTPROCESS_COMMAND}")
        separate_arguments(LOCAL_POSTPROCESS_COMMAND_SEPARATED UNIX_COMMAND ${LOCAL_POSTPROCESS_COMMAND})
        add_custom_command(
            TARGET ${target_name_}
            POST_BUILD
            COMMAND ${LOCAL_POSTPROCESS_COMMAND_SEPARATED}
        )
    endif()
endfunction()

# set target-defined definitions
{{ set_definitions }}
{% endif %}

project({{ component.getName() }})

{% if toplevel %}
# Definitions provided by the target configuration info:
if(NOT DEFINED YOTTA_FORCE_INCLUDE_FLAG)
    # backwards-compatibility hack for ARMCC only: Do not add new compilers here!
    if("${CMAKE_C_COMPILER_ID}" STREQUAL "ARMCC")
        set(YOTTA_FORCE_INCLUDE_FLAG "--preinclude")
    else()
        set(YOTTA_FORCE_INCLUDE_FLAG "-include")
    endif()
endif()
add_definitions("${YOTTA_FORCE_INCLUDE_FLAG} \"{{ config_include_file | replaceBackslashes }}\"")
{% endif %}

# include root directories of all components we depend on (directly and
# indirectly, including ourself)
{{ include_root_dirs }}

# recurse into dependencies that aren't built elsewhere
{{ add_depend_subdirs }}

{% if include_sys_dirs %}
# Some components (I'm looking at you, libc), need to export system header
# files with no prefix, these directories are listed in the component
# description files:
{{ include_sys_dirs }}
{% endif %}

{% if include_other_dirs %}
# And others (typically CMSIS implementations) need to export non-system header
# files. Please don't use this facility. Please. It's much, much better to fix
# implementations that import these headers to import them using the full path.
{{ include_other_dirs }}
{% endif %}

# modules with custom CMake build systems may append to the
# YOTTA_GLOBAL_INCLUDE_DIRS property to add compile-time-determined include
# directories:
get_property(GLOBAL_INCLUDE_DIRS GLOBAL PROPERTY YOTTA_GLOBAL_INCLUDE_DIRS)
include_directories(${GLOBAL_INCLUDE_DIRS})

# Provide versions of all the components we depend on, the corresponding
# preprocessor definitions are generated in yotta_config.h
{% for dep in list(active_dependencies.values()) + [component] %}
set(YOTTA_{{ dep.getName() | sanitizePreprocessorSymbol }}_VERSION_STRING "{{ dep.getVersion() }}")
set(YOTTA_{{ dep.getName() | sanitizePreprocessorSymbol }}_VERSION_MAJOR {{ dep.getVersion().major() }})
set(YOTTA_{{ dep.getName() | sanitizePreprocessorSymbol }}_VERSION_MINOR {{ dep.getVersion().minor() }})
set(YOTTA_{{ dep.getName() | sanitizePreprocessorSymbol }}_VERSION_PATCH {{ dep.getVersion().patch() }})
{% endfor %}

{% if delegate_to %}
# delegate to an existing CMakeLists.txt:
add_subdirectory(
    "{{ delegate_to | replaceBackslashes }}"
    "{{ delegate_build_dir | replaceBackslashes }}"
)
{% else %}
# recurse into subdirectories for this component, using the two-argument
# add_subdirectory because the directories referred to here exist in the source
# tree, not the working directory
{% for srcdir, workingdir in add_own_subdirs %}
add_subdirectory(
    "{{ srcdir | replaceBackslashes }}"
    "${CMAKE_BINARY_DIR}/{{ relpath | replaceBackslashes }}/{{ workingdir | replaceBackslashes }}"
)
{% endfor %}
{% endif %}
