# NOTE: This file is generated from {{ self }}: changes will be overwritten!

{% if toplevel %}
cmake_minimum_required(VERSION 2.8.11)

enable_testing()

# add a dummy target for all autogenerated tests, so we can build them all
# even though they are EXCLUDE_FROMALL'd, if you use custom CMakeLists you can
# add a dependency of this target on your test programs, by adding:
# add_dependencies(all_tests your_test_name)
add_custom_target(all_tests)


# always use the CMAKE_MODULE_PATH-provided .cmake files, even when including
# from system directories:
cmake_policy(SET CMP0017 OLD)

# toolchain file for {{ target_name }}
set(CMAKE_TOOLCHAIN_FILE "{{ toolchain_file | relative | replaceBackslashes }}")

# template replacement
configure_file( yotta_config.h.cmake_template yotta_config.h )

# provide function for post-processing executables
function (yotta_postprocess_target target_type_ target_name_)
    if(COMMAND yotta_apply_target_rules)
        yotta_apply_target_rules(${target_type_} ${target_name_})
    endif()

    # For backwards compatibility, support YOTTA_POSTPROCESS_COMMAND.
    if(DEFINED YOTTA_POSTPROCESS_COMMAND AND ${target_type_} STREQUAL "EXECUTABLE")
        #message(AUTHOR_WARNING "This target defines a YOTTA_POSTPROCESS_COMMAND for which support has been deprecated. Please define a CMake function yotta_apply_target_rules(build_object_type build_object) instead.")
        string(REPLACE YOTTA_CURRENT_EXE_NAME "${target_name_}" LOCAL_POSTPROCESS_COMMAND "${YOTTA_POSTPROCESS_COMMAND}")
        separate_arguments(LOCAL_POSTPROCESS_COMMAND_SEPARATED UNIX_COMMAND ${LOCAL_POSTPROCESS_COMMAND})
        add_custom_command(
            TARGET ${target_name_}
            POST_BUILD
            COMMAND ${LOCAL_POSTPROCESS_COMMAND_SEPARATED}
        )
    endif()
endfunction()

# set target-defined definitions
{{ set_definitions }}
{% endif %}

project({{ component.getName() }})

{% if toplevel %}
# Definitions provided by the target configuration info:
if(NOT DEFINED YOTTA_FORCE_INCLUDE_FLAG)
    # backwards-compatibility hack for ARMCC only: Do not add new compilers here!
    if("${CMAKE_C_COMPILER_ID}" STREQUAL "ARMCC")
        set(YOTTA_FORCE_INCLUDE_FLAG "--preinclude")
    else()
        set(YOTTA_FORCE_INCLUDE_FLAG "-include")
    endif()
endif()
add_definitions("${YOTTA_FORCE_INCLUDE_FLAG} \"${CMAKE_BINARY_DIR}/{{ config_include_file | relative | replaceBackslashes }}\"")
{% endif %}

# include root directories of all components we depend on (directly and
# indirectly, including ourself)
{% for dir in include_root_dirs %}
include_directories("${CMAKE_BINARY_DIR}/{{ dir | relative | replaceBackslashes }}")
{% endfor %}

{% if add_depend_subdirs %}
# recurse into dependencies that aren't built elsewhere
{% for depend_subdir, relpath in add_depend_subdirs %}
add_subdirectory(
    "${CMAKE_BINARY_DIR}/{{ relpath | replaceBackslashes }}"
    "${CMAKE_BINARY_DIR}/{{ depend_subdir | replaceBackslashes }}"
)

{% endfor %}
{% endif %}
{% if include_sys_dirs %}
# Some components (I'm looking at you, libc), need to export system header
# files with no prefix, these directories are listed in the component
# description files:
{% for dir in include_sys_dirs %}
include_directories(SYSTEM "${CMAKE_BINARY_DIR}/{{ dir | relative | replaceBackslashes }}")
{% endfor %}

{% endif %}
{% if include_other_dirs %}
# And others (typically CMSIS implementations) need to export non-system header
# files. Please don't use this facility. Please. It's much, much better to fix
# implementations that import these headers to import them using the full path.
{% for dir in include_other_dirs %}
include_directories("${CMAKE_BINARY_DIR}/{{ dir | relative | replaceBackslashes }}")
{% endfor %}

{% endif %}
# modules with custom CMake build systems may append to the
# YOTTA_GLOBAL_INCLUDE_DIRS property to add compile-time-determined include
# directories:
get_property(GLOBAL_INCLUDE_DIRS GLOBAL PROPERTY YOTTA_GLOBAL_INCLUDE_DIRS)
include_directories(${GLOBAL_INCLUDE_DIRS})

# Provide versions of all the components we depend on, the corresponding
# preprocessor definitions are generated in yotta_config.h
{% for dep in list(active_dependencies.values()) + [component] %}
set(YOTTA_{{ dep.getName() | sanitizePreprocessorSymbol }}_VERSION_STRING "{{ dep.getVersion() }}")
set(YOTTA_{{ dep.getName() | sanitizePreprocessorSymbol }}_VERSION_MAJOR {{ dep.getVersion().major() }})
set(YOTTA_{{ dep.getName() | sanitizePreprocessorSymbol }}_VERSION_MINOR {{ dep.getVersion().minor() }})
set(YOTTA_{{ dep.getName() | sanitizePreprocessorSymbol }}_VERSION_PATCH {{ dep.getVersion().patch() }})
{% endfor %}

# provide the name of the current module so that it's available to custom CMake
# even if custom CMake does weird things with project()
set(YOTTA_MODULE_NAME {{ component.getName() }})

{% if delegate_to %}
# delegate to an existing CMakeLists.txt:
add_subdirectory(
    "${CMAKE_BINARY_DIR}/{{ delegate_to | relative | replaceBackslashes }}"
    "${CMAKE_BINARY_DIR}/{{ delegate_build_dir | relative | replaceBackslashes }}"
)
{% else %}
# recurse into subdirectories for this component, using the two-argument
# add_subdirectory because the directories referred to here exist in the source
# tree, not the working directory
{% for srcdir, workingdir in add_own_subdirs %}
add_subdirectory(
    "${CMAKE_BINARY_DIR}/{{ srcdir | relative | replaceBackslashes }}"
    "${CMAKE_BINARY_DIR}/{{ workingdir | replaceBackslashes }}"
)
{% endfor %}
{% endif %}

{% if not module_is_empty %}
# make YOTTA_MODULE_NAME available as a preprocessor symbol when
# compiling this module:
target_compile_definitions({{ component.getName() }} PRIVATE "-DYOTTA_MODULE_NAME={{ component.getName() }}")
{% else %}
# (not setting YOTTA_MODULE_NAME preprocessor definition as this module doesn't
# have any sources to build)
{% endif %}

{% if cmake_includes %}
# include .cmake files provided by the target:
{% for f in cmake_includes %}
include("${CMAKE_BINARY_DIR}/{{ f | relative | replaceBackslashes }}")
{% endfor %}
{% endif %}
